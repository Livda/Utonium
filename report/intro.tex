\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

%Contexte

Au cours de ces dernières années, les techniques émergentes de l’ingénierie des modèles et de la programmation générative se sont bien mis en place dans l’industrie afin de faciliter le développement logiciel.

La génération automatique de code source par exemple, est une opération permettant de générer automatiquement du code source à partir d’une spécification haut-niveau. Son but est de simplifier et automatiser la production de code source répétitif afin de minimiser les risques d'erreurs de programmation et soulager le développeur de certaines phases de développement, parfois lourde complexe.

En effet, la plupart des outils et environnements de développement aujourd’hui, fournissent différents types de générateurs de code (voir une liste non-exhaustive \cite{liste_generateurs}). Par exemple, un des types phares de générateurs, il y a ceux qui prennent comme entrée une définition abstraite (p.ex, UML, Ecore, etc) et génèrent du code source ou des exécutables vers différentes plateformes d’exécution logicielle (p.ex., Java, C\#, C/C++, etc).

%Description du problème

La génération automatique de source code est certe efficaces pour améliorer la production logicielle. Cependant, les développeurs de générateurs de code manquent d’outils de test et vérification du processus de génération de code. Une simple méthode de test de générateurs est de vérifier le bon fonctionnement des différents artifacts logiciel générés. Il s’agit donc de décrire des test unitaires pour les programmes générés dans différents langages . Cette manière de faire requiert beaucoup de temps et nécessite une maîtrise des langages de programmation cibles.
En outre, un générateur de code “non-mature” peut violer certaines propriétés non-fonctionnelles QoS et affecter la qualité du logiciel généré (i.e., temps d'exécution relativement long, utilisation intensive de la mémoire et CPU, etc). En effet, certains services générés peuvent être déployés et exécutés sur différentes plateformes hétérogènes et distribuées (p.ex., internet des objets, capteurs, Cloud, mobile, web, etc.). Cependant, ces plateformes d’exécution sont généralement dotées de ressources très limitées et prennent en compte plusieurs contraintes variées tel que l’espace mémoire restreint, la consommation d’énergie, etc. Ainsi, certaines contraintes non-fonctionnelles peuvent empêcher la bonne exécution et la performance de ces services.

\hspace{15pt}

%Description de la soution (tres succinte) & evaluation

Ce projet a pour but de développer un outil de test automatique des générateurs de code. Nous pouvions choisir de tester des générateurs proposés dan	s \cite{liste_generateurs}. Nous avons choisi d'utiliser Java et ses modules JUnit pour tester les générateurs suivants :

\todo{Fixer les générateurs}
\begin{itemize}
    \item javac,
    \item elvm,
    \item moolinet (un autre projet de test mené par Quentin Dufour et Loïck Bonniot)
\end{itemize}
