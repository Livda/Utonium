\chapter{Évaluation}

Pendant le développement de notre programme, nous avons utilisé nos propres appels aux différents compilateurs que nous utilisons. Il s'agit de petits
tests qui assurent que notre programme se déroule bien et que les fonctions basiques de notre programme soient stables. Cela nous a permis d'optimiser
notre temps en écrivant à la fois les tests de notre logiciel et une évaluation de notre logiciel. Nous avons aussi décidé de tester le projet
d'autres étudiants, Moolinet. Nous avons donc écris des cas de tests dans le langage qu'ils ont défini pour tester la compilation de ceux-ci et l’exécution
dans leur fuzzer.

Les performances de notre testeur vont dépendre quasiment uniquement des appels aux différents compilateurs, le point
qui peut prendre le plus de temps est la compilation et l’exécution du code. Mais sachant que la plupart du temps,
on cherche à garder des tests les plus petits possible, pour cibler le plus précisément un bug, les temps d'exécution des programmes sont
relativement faibles.

Le passage à l'échelle n'est pas pris en compte dans notre solution, mais il pourrait
l'être si l'on parallélise les appels système. Ainsi, dans un cluster de calculateurs,
chacune des machines pourrait tester ses fonctions sans impacter les autres tests. Notre
solution utilisant des processus déjà existants, il faut juste rendre ces processus
passables à l'échelle.
